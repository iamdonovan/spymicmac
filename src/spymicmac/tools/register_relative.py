#!/usr/bin/env python
import argparse
from spymicmac.register import register_relative


def _argparser():
    helpstr = "Register a relative DEM or orthoimage to a reference DEM and/or orthorectified image."

    _parser = argparse.ArgumentParser(description=helpstr,
                                      formatter_class=argparse.RawDescriptionHelpFormatter)
    _parser.add_argument('dirmec', action='store', type=str,
                         help='the name of the MEC directory to read the relative DEM from (e.g., MEC-Relative)')
    _parser.add_argument('fn_dem', action='store', type=str, help='path to reference DEM')
    _parser.add_argument('-ref', '--fn_ref', action='store', type=str, default=None,
                         help='path to reference orthorectified image (optional)')
    _parser.add_argument('-ort', '--fn_ortho', action='store', type=str, default=None,
                         help='path to relative orthoimage (optional)')
    _parser.add_argument('-glacmask', action='store', type=str, default=None,
                         help='path to shapefile of glacier outlines (i.e., an exclusion mask)')
    _parser.add_argument('-landmask', action='store', type=str, default=None,
                         help='path to shapefile of land outlines (i.e., an inclusion mask)')
    _parser.add_argument('-footprints', action='store', type=str, default=None,
                         help='path to shapefile of image outlines. If not set, will look for Footprints.gpkg '
                              'in the current directory. If this file does not exist, will attempt to download '
                              'from USGS using imgsource.')
    _parser.add_argument('-im_subset', action='store', type=str, default=None, nargs='+',
                         help='subset of raw images to work with (default: all)')
    _parser.add_argument('-b', '--block_num', action='store', type=str, default=None,
                         help='block number to use if processing multiple image blocks.')
    _parser.add_argument('--subscript', action='store', type=str, default=None,
                         help='optional subscript to use for output filenames.')
    _parser.add_argument('-ori', action='store', type=str, default='Relative',
                         help='name of orientation directory (after Ori-) (default: Relative).')
    _parser.add_argument('-ortho_res', action='store', type=float, default=8,
                         help='approx. ground sampling distance (pixel resolution) of ortho image. (default: 8 m)')
    _parser.add_argument('-imgsource', action='store', type=str, default='DECLASSII',
                         help='USGS dataset name for images (default: DECLASSII).')
    _parser.add_argument('-strategy', action='store', type=str, default='grid',
                         help="strategy for generating GCPs. Must be one of: grid, random, or chebyshev. "
                              "Note that if 'random' is used, density is the approximate number of points, "
                              "rather than the distance between grid points (default: grid).")
    _parser.add_argument('-density', action='store', type=int, default=200,
                         help='pixel spacing to look for GCPs (default: 200)')
    _parser.add_argument('-no_allfree', action='store_false',
                         help='run Campari with AllFree set to False')
    _parser.add_argument('-useortho', action='store_true',
                         help='use the orthomosaic in Ortho-{dirmec} rather than the DEM. '
                              'If fn_ortho is set, uses that file instead (default: False).')
    _parser.add_argument('-max_iter', action='store', type=int, default=5,
                         help='the maximum number of Campari iterations to run (default: 5)')
    _parser.add_argument('-use_cps', action='store_true',
                         help='split the GCPs into GCPs and checkpoints (CPs), to quantify the uncertainty '
                              'of the camera model (default: False).')
    _parser.add_argument('-cp_frac', type=float, default=0.2,
                         help='the fraction of GCPs to use as CPs when splitting into GCPs and CPs (default: 0.2)')
    _parser.add_argument('-o', '--use_orb', action='store_true',
                         help='use skimage.feature.ORB to identify GCP locations in the reference image '
                              '(default: use points generated by strategy)')
    _parser.add_argument('-fn_gcps', action='store', type=str, default=None,
                         help='(optional) shapefile or CSV of GCP coordinates to use. Column names should be '
                              '[(name | id), (z | elevation), x, y]. If CSV is used, x,y should have the same '
                              'CRS as the reference image.')
    return _parser


def main():
    parser = _argparser()
    args = parser.parse_args()

    args.allfree = not args.no_allfree
    delattr(args, 'no_allfree')

    register_relative(**vars(args))


if __name__ == "__main__":
    main()
